# Task 1:
# Create a programatic configuration of a context free grammar

V = {'S'}                   # non-terminal symbols
E = {'a', 'b'}              # terminal symbols
R = {
    'S': ['aSb', '']        # production rules
}
S = 'S'                     # start symbol 

# Task 2:
# Randomly generate strings from the CFG

import random

def generate_string(max_strings = 10, max_length = 10):
    
    strings_list = set()

    def expand(new_string):
        # If we have reached the maximum number of strings, stop
        if len(strings_list) >= max_strings or len(new_string) > max_length:
            return
        
        if all(char in E for char in new_string):
            # If the string is terminal and within length, add to results
            if len(new_string) <= max_length:
                strings_list.add(new_string)
            return
        
        else:
            # Otherwise, expand the leftmost non-terminal
            for char in set(new_string):
                if char in V:
                    for choice in random.sample(R[char], k=len(R[char])):
                        expansion = new_string.replace(char, choice, 1)
                        expand(expansion)
                    break
    
    expand(S)
    return strings_list

generated_strings = generate_string()
print("Generated strings:", generated_strings)

# Task 3:
# Displays a string's derivation 

def derivation(string):
    
    if not set(string) <= E:
        return "Invalid string: contains non-terminal symbols."
    
    if string == '':
        return "S => e"
    
    def derive(steps_number):
        if steps_number == 0:
            return ["S", '']
        
        previous_steps = derive(steps_number - 1)
        steps = ['S']
        for step in previous_steps:
            if step != "":
                steps.append('a' + step + 'b')
        
        return steps
    
    steps = derive(len(string) // 2)
    
    if "S" in steps[-1]:
        steps.append("".join([char for char in steps[-1] if char in E]))
        
    derivation_steps = [step if step != '' else 'e' for step in steps] 
    return " => ".join(derivation_steps)

for string in generated_strings:
    print(f"Derivation of '{string}': {derivation(string)}")
    
# Task 4:
# Verify if a string is in the language generated by the CFG

def verification(string):
    length = len(string)
    
    if length == 0:
        return True
    
    if length % 2 != 0:
        return False
    
    if string[0] == 'a' and string[-1] == 'b':
        return verification(string[1:-1])
    
    return False

for string in generated_strings:
    is_valid = verification(string)
    print(f"'{string}': {'Yes' if is_valid else 'No'}")

string_to_verify = ['aab', 'abb', 'aacbb', 'abab', 'aaabb', 'aaabbbb']

for string in string_to_verify:
    is_valid = verification(string)
    print(f"'{string}': {'Yes' if is_valid else 'No'}")